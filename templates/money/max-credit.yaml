starterNode: webhook
nodes:
  webhook:
    type: webhook
    parameters:
      path: /max-credit
      method: post
      validation:
        queryParameters:
          document:
            type: string
            required: true
        body:
          type: object
          properties:
            consignableMargin:
              type: number
            iof:
              type: number
            fee:
              type: number
            product:
              type: object
              required:
                - metaData
              properties:
                slug:
                  type: string
                eligibilitySettings:
                  type: object
                metaData:
                  type: object
          required:
            - consignableMargin
            - iof
            - fee
            - product
      next: set-ctx-constants
  set-ctx-constants:
    type: function
    parameters:
      code: |-
        $.ctx.installments = []
        $.ctx.HTTP_REQUEST_TIMEOUT = 5000
        const base39 = {
          baseUrl: $.secrets.base39BaseUrl
        }
        $.ctx.base39 =  base39
      next: find-customer
  find-customer:
    type: http-request
    parameters:
      timeout: "{{ $.ctx.constants.HTTP_REQUEST_TIMEOUT }}"
      method: GET
      headers: &base39ApiHeader
        "Content-Type": application/json
        "accept": "application/json"
        "x-api-key": "{{ $.secrets.base39ApiKey }}"
      url: "{{ $.ctx.base39.baseUrl }}/customers"
      queryParameters:
        document: "{{ $.nodes.webhook[0].output.queryParameters.document }}"
      ignoreResponseCode: true
      next: check-customer
  check-customer:
    type: conditional
    parameters:
      conditions:
        - next: response-error-no-customer
          expressions:
            - leftValue: '{{ $.nodes."find-customer"[0].output.responseData.data }}'
              operation: empty
      default: find-employments
  find-employments:
    type: http-request
    parameters:
      timeout: "{{ $.ctx.constants.HTTP_REQUEST_TIMEOUT }}"
      method: GET
      headers: *base39ApiHeader
      url: "{{ $.ctx.base39.baseUrl }}/employments"
      queryParameters:
        document: "{{ $.nodes.webhook[0].output.queryParameters.document }}"
      ignoreResponseCode: true
      next: check-employments
  check-employments:
    type: conditional
    parameters:
      conditions:
        - next: response-error-no-employment
          expressions:
            - leftValue: '{{ $.nodes."find-employments"[0].output.responseData.data }}'
              operation: empty
      default: find-companies
  find-companies:
    type: loop
    parameters:
      items: '{{ $.nodes."find-employments"[0].output.responseData.data[*].company }}'
      starterNode: find-company
      concurrency: 10
      next: find-open-loans
  find-company:
    type: http-request
    parameters:
      timeout: "{{ $.ctx.constants.HTTP_REQUEST_TIMEOUT }}"
      method: GET
      headers: *base39ApiHeader
      url: "{{ $.ctx.base39.baseUrl }}/companies/{{ $.flow.loop.item }}"
      ignoreResponseCode: true
  find-open-loans:
    type: http-request
    parameters:
      timeout: "{{ $.ctx.constants.HTTP_REQUEST_TIMEOUT }}"
      method: GET
      headers: *base39ApiHeader
      queryParameters:
        customer: '{{ $.nodes."find-customer".output.responseData.data[0].id }}'
        status: open
        limit: 100
        starting_after: '{{ $.nodes."find-open-loans"[-1].output.responseData.data[-1].id }}'
      url: "{{ $.ctx.base39.baseUrl }}/loans"
      next: find-open-loans-check-pagination
  find-open-loans-check-pagination:
    type: conditional
    parameters:
      conditions:
        - next: find-open-loans
          expressions:
            - leftValue: '{{ $.nodes."find-open-loans"[-1].output.responseData.hasMore }}'
              operation: equal
              rightValue: true
      default: find-disbursed-loans
  find-disbursed-loans:
    type: http-request
    parameters:
      timeout: "{{ $.ctx.constants.HTTP_REQUEST_TIMEOUT }}"
      method: GET
      headers: *base39ApiHeader
      queryParameters:
        customer: '{{ $.nodes."find-customer".output.responseData.data[0].id }}'
        status: disbursed
        limit: 100
        starting_after: '{{ $.nodes."find-disbursed-loans"[-1].output.responseData.data[-1].id }}'
      url: "{{ $.ctx.base39.baseUrl }}/loans"
      next: find-disbursed-loans-check-pagination
  find-disbursed-loans-check-pagination:
    type: conditional
    parameters:
      conditions:
        - next: find-disbursed-loans
          expressions:
            - leftValue: '{{ $.nodes."find-open-loans"[-1].output.responseData.hasMore }}'
              operation: equal
              rightValue: true
      default: merge-loans
  merge-loans:
    type: function
    parameters:
      code: |
        const findDisbursedLoans = $.nodes["find-disbursed-loans"]
        const findOpenLoans = $.nodes["find-open-loans"]

        const openedLoans = []
        const disbursedLoans = []

        findDisbursedLoans.forEach(execution => {
          disbursedLoans.push(...execution.output.responseData.data)
        })

        findOpenLoans.forEach(execution => {
          openedLoans.push(...execution.output.responseData.data)
        })

        return {
          loansIds: [
            ...openedLoans.map(loan => loan.id),
            ...disbursedLoans.map(loan => loan.id),
          ],
          openedLoans,
          disbursedLoans
        }
      next: find-loans-installments
  find-loans-installments:
    type: loop
    parameters:
      items: '{{ $.nodes."merge-loans"[0].output.loansIds }}'
      starterNode: find-installments
      concurrency: 10
      next: sum-loans
  find-installments:
    type: http-request
    parameters:
      timeout: "{{ $.ctx.constants.HTTP_REQUEST_TIMEOUT }}"
      method: GET
      headers: *base39ApiHeader
      queryParameters:
        limit: 100
        starting_after: '{{ $.nodes."find-installments"[-1].output.responseData.data[-1].id }}'
      url: "{{ $.ctx.base39.baseUrl }}/loans/{{ $.flow.loop.item }}/installments"
      next: find-installments-check-pagination
  find-installments-check-pagination:
    type: conditional
    parameters:
      conditions:
        - next: find-installments
          expressions:
            - leftValue: '{{ $.nodes."find-installments"[-1].output.responseData.hasMore }}'
              operation: equal
              rightValue: true
  sum-loans:
    type: function
    parameters:
      code: |
        const disbursedLoans = $.nodes["merge-loans"][0].output.disbursedLoans
        const openedLoans = $.nodes["merge-loans"][0].output.openedLoans
        const findInstallmentExecutions = $.nodes["find-installments"]

        const loans = [
          ...disbursedLoans,
          ...openedLoans
        ]

         function sumInstallments(acc, loan) {
          return acc + (!!loan.installments.data[0]?.totalAmount ? loan.installments.data[0].totalAmount : 0)
        }

        function sumTotalAmount(acc, installment) {
          return acc + installment.totalAmount
        }

        function sumInstallmentsTotalAmount(acc, execution) {
          return acc + execution.output.responseData.data.reduce(sumTotalAmount, 0)
        }       

        const totalAmount = findInstallmentExecutions ? findInstallmentExecutions.reduce(sumInstallmentsTotalAmount, 0) : 0
        const totalInstallments = loans ? loans.reduce(sumInstallments, 0) : 0
        const totalDisbursedLoans = disbursedLoans ? disbursedLoans.length : 0

        return {
          totalInstallments,
          totalAmount,
          totalDisbursedLoans
        }
      next: calculate-loop
  calculate-loop:
    type: loop
    parameters:
      items: '{{ $.nodes."find-employments"[0].output.responseData.data[*] }}'
      starterNode: calculate-max-installment
      concurrency: 10
      next: webhook-response
  calculate-max-installment:
    type: function
    parameters:
      code: |
        const maxInstallmentReduction = $.nodes["sum-loans"][0].output.totalInstallments
        const netSalary = $.flow.loop.item.netSalary
        const limitPerInstallment = $.flow.loop.item.limitPerInstallment

        const estimatedMaxInstallment = netSalary * $.nodes.webhook[0].output.body.consignableMargin
        const maxInstallment = Math.max(estimatedMaxInstallment - maxInstallmentReduction, 0)
        return Math.min(maxInstallment, limitPerInstallment)
      next: calculate-max-credit
  calculate-max-credit:
    type: function
    parameters:
      code: |
        const { differenceInDays, startOfDay, addMonths } = require('date-fns')
        const BigNumber = require('bignumber.js')

        const grossSalary = $.flow.loop.item.grossSalary
        const limitPerLoan = $.flow.loop.item.limitPerLoan
        const iof = $.nodes.webhook[0].output.body.iof
        const monthlyFee = $.nodes.webhook[0].output.body.fee
        const { maxNumberOfInstallments } = $.nodes.webhook[0].output.body.product.metaData
        const maxCreditReduction = $.nodes["sum-loans"][0].output.totalInstallments + grossSalary * iof
        const maxInstallmentValue = $.flow.nodes["calculate-max-installment"][0].output

        const firstDueDate = new Date()

        let sum = 0
        for (let i = 0; i < maxNumberOfInstallments; i++) {
          const datam = addMonths(startOfDay(new Date(firstDueDate)), i)
          const diffDays = differenceInDays(datam, startOfDay(new Date()))
          const monthlyFeeMultiplier = (monthlyFee / 100) + 1
          const diffInMonths = new BigNumber(diffDays).dividedBy(30)
          const compondFee = Math.pow(monthlyFeeMultiplier, diffInMonths.toNumber())
          sum += Math.pow(compondFee, -1)
        }

        const estimatedMaxCredit = sum * maxInstallmentValue
        const maxCredit = Math.max(estimatedMaxCredit - maxCreditReduction, 0)
        return Math.min(maxCredit, limitPerLoan)
      next: round-values
  round-values:
    type: function
    parameters:
      code: |
        const maxInstallment = $.flow.nodes['calculate-max-installment'][0].output
        const maxCredit = $.flow.nodes['calculate-max-credit'][0].output

        function roundByPlaceValue(maxCredit) {
          const place = Math.trunc(Math.round((100 * Math.log(maxCredit)) / Math.log(10)) / 100)
          const placeValue = place < 2 ? 1 : Math.pow(10, place - 1)
          return Math.max(Math.floor(maxCredit / placeValue) * placeValue, 0)
        }

        return {
          maxInstallment: roundByPlaceValue(maxInstallment),
          maxCredit: roundByPlaceValue(maxCredit)
        }
      next: bind-response
  bind-response:
    type: function
    parameters:
      code: |
        const { maxCredit, maxInstallment } = $.flow.nodes['round-values'][0].output
        const { maxNumberOfInstallments, minNumberOfInstallments, minLoanAmount } = $.nodes.webhook[0].output.body.product.metaData

        return {
          slug: $.nodes.webhook[0].output.body.product.slug,
          name: "string",
          description: "string",
          maxLoanAmount: maxCredit,
          minLoanAmount,
          maxNumberOfInstallments,
          minNumberOfInstallments,
          maxInstallmentValue: maxInstallment,
          minInstallmentValue: maxCredit / maxNumberOfInstallments,
          customer: $.nodes['find-customer'][0].output.responseData.data[0].id,
          employment: $.flow.loop.item.id,
          available: true,
          metadata: {}
        }
  webhook-response:
    type: webhook-response
    parameters:
      statusCode: 200
      body:
        data: '{{ $.nodes."bind-response"[*].output }}'
  response-error-no-employment:
    type: webhook-response
    parameters:
      statusCode: 404
      body:
        code: EMPLOYMENT_NOT_FOUND
        message: "No employment found for the given document."
  response-error-no-customer:
    type: webhook-response
    parameters:
      statusCode: 404
      body:
        code: CUSTOMER_NOT_FOUND
        message: "No customer found for the given document."
