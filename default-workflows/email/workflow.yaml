# Inputs:
# - invoiceStatus: string[]
# - dateDaysOffset: number
# - dateOperationDirection: string (after|before)
# - messageSubject: string
# - messageText: string

starterNode: processa_inputs
nodes:
  processa_inputs:
    type: function
    friendlyName: Processa inputs
    parameters:
      code: |
        const { addDays, subDays, startOfDay, endOfDay } = require('date-fns')

        const currentDate = new Date()

        const dateOperationFn = $.ctx.inputs.dateOperationDirection === 'after' ? subDays : addDays
        const targetDate = dateOperationFn(currentDate, $.ctx.inputs.dateDaysOffset)

        return {
          invoiceStatus: $.ctx.inputs.invoiceStatus.join(','),
          startDate: startOfDay(targetDate),
          endDate: endOfDay(targetDate),
        }
      next: busca_faturas_por_vencimento
  busca_faturas_por_vencimento:
    type: http-request
    friendlyName: Buscar faturas por vencimento
    parameters:
      app: internalApi
      url: /v1/invoices
      method: get
      timeout: 30000
      queryParameters:
        type: customer_recurring,company_recurring
        due_date_start: "{{ $.nodes.processa_inputs[0].output.startDate }}"
        due_date_end: "{{ $.nodes.processa_inputs[0].output.endDate }}"
        status: "{{ $.nodes.processa_inputs[0].output.invoiceStatus }}"
        starting_after: '{{ $.nodes."busca_faturas_por_vencimento"[-1].output.body.data[-1].id }}'
        limit: 100
        fields: data.id,data.payer,data.status,data.beneficiary,data.dueDate,data.amountDue,data.amountPaid,data.amountRemaining,data.type
      next: busca_faturas_por_vencimento-check-pagination
  busca_faturas_por_vencimento-check-pagination:
    type: conditional
    parameters:
      conditions:
        - next: busca_faturas_por_vencimento
          expressions:
            - leftValue: '{{ $.nodes."busca_faturas_por_vencimento"[-1].output.body.hasMore }}'
              operation: equal
              rightValue: true
      default: envia_e-mails_por_fatura-loop
  envia_e-mails_por_fatura-loop:
    type: loop
    friendlyName: Envia e-mails por fatura
    parameters:
      items: "{{ $.nodes.busca_faturas_por_vencimento[*].output.body.data[] }}"
      concurrency: 1
      starterNode: obtem_tipo_pagador_fatura
  obtem_tipo_pagador_fatura:
    type: function
    friendlyName: Obtém tipo pagador fatura
    parameters:
      code: |
        const { payer } = $.flow.loop.item

        const isCustomer = /^cust_/.test(payer)

        return isCustomer ? 'customer' : 'company'
      next: verifica_tipo_pagador_fatura
  verifica_tipo_pagador_fatura:
    type: conditional
    friendlyName: Verifica tipo pagador fatura
    parameters:
      conditions:
        - next: busca_dados_cliente
          expressions:
            - leftValue: "{{ $.flow.nodes.obtem_tipo_pagador_fatura[0].output }}"
              operation: equal
              rightValue: customer
      default: busca_dados_operador
  busca_dados_cliente:
    type: http-request
    friendlyName: Buscar faturas por vencimento
    parameters:
      app: internalApi
      url: "/v1/customers/{{ $.flow.loop.item.payer }}"
      method: get
      timeout: 30000
      fields: id,name,document,email,username,phone
      next: data
  busca_dados_operador:
    type: http-request
    friendlyName: Buscar faturas por vencimento
    parameters:
      app: internalApi
      url: "/v1/operators"
      method: get
      timeout: 30000
      queryParameters:
        company: "{{ $.flow.loop.item.payer }}"
        role: financial
        fields: data.id,data.name,data.document,data.username,data.email
        limit: 1
      next: data
  data:
    type: function
    friendlyName: Cria dados template
    parameters:
      code: |
        const payerType = $.flow.nodes.obtem_tipo_pagador_fatura[0].output;
        const DEFAULT_TIMEZONE = "America/Sao_Paulo";

        const formatDatePtBr = (date, timeZone = DEFAULT_TIMEZONE) => {
          if (!date) {
            return ''
          }

          const formatter = new Intl.DateTimeFormat("pt-BR", {
            timeZone,
            dateStyle: "short",
          });

          return formatter.format(new Date(date));
        };

        const formatMonetaryValuePtBr = (value, options) => {
          if (!value) {
            return '0,00'
          }
          
          const formatter = Intl.NumberFormat(
            "pt-BR",
            options ?? {
              minimumFractionDigits: 2,
              maximumFractionDigits: 2,
            }
          );

          return formatter.format(value);
        };

        let payerData;
        if (payerType === "customer") {
          payerData = $.flow.nodes.busca_dados_cliente[0].output.body;
        } else {
          payerData = $.flow.nodes.busca_dados_operador[0].output.body?.data[0];
        }

        const templateData = {
          payer: payerData,
          invoice: {
            ...$.flow.loop.item,
            dueDate: formatDatePtBr($.flow.loop.item.dueDate),
            amountDue: formatMonetaryValuePtBr($.flow.loop.item.amountDue),
            amountPaid: formatMonetaryValuePtBr($.flow.loop.item.amountPaid),
            amountRemaining: formatMonetaryValuePtBr($.flow.loop.item.amountRemaining),
          },
        };

        $.ctx.data = templateData;
        return templateData;
      next: verifica_email_destinatario
  verifica_email_destinatario:
    type: conditional
    friendlyName: Verifica e-mail destinatário
    parameters:
      conditions:
        - next: envia_e-mail_fatura_a_vencer
          expressions:
            - leftValue: "{{ $.ctx.data.payer.email }}"
              operation: not-empty
  envia_e-mail_fatura_a_vencer:
    type: smtp
    friendlyName: Envia e-mail fatura a vencer
    parameters:
      app: settings.notifications.email
      to: "{{ $.ctx.data.payer.email }}"
      subject: "{{ $.ctx.inputs.messageSubject }}"
      text: "{{ $.ctx.inputs.messageText }}"
